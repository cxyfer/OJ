"""
分別考慮每個位元的貢獻，只有 M 中的第 i 位為 1 才有貢獻，累加有多少數字第 i 位為 1 至答案中

若 M 的第 2 位為 1 、且 N 為 14 = 01110，則有以下數字第 2 位為 1：
00100, 00101, 00110, 00111, 01100, 01101, 01110
數量等同 N 去除第 2 位後再加 1 ， 01110 -> 0110 = 6 -> 7

上述為 N 的第 i 位恰好為 1 的情況，但也需考慮 N 的第 i 位不是 1 的情況
可以減去 1 << i 後再 OR mask，即為 [1, n] 中該位為 1 的最大數字
"""

N, M = map(int, input().split())
MOD = 998244353
ans = 0
# for i in range(60):
for i in range(M.bit_length()):
    if M & (1 << i):
        mask = (1 << i) - 1
        mx = N if N & (1 << i) else (N - (1 << i)) | mask # [1, N] 中第 i 位為 1 的最大數字
        x = ((mx >> (i + 1)) << i) | (mx & mask) # 刪除 N 的第 i 位
        ans = (ans + x + 1) % MOD # x + 1 即為 [1, N] 中第 i 位為 1 的數字數量
print(ans)
