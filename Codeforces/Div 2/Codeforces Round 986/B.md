要解決這個問題，我們需要分析Alice的操作如何將陣列轉換為一個排列。以下是解題的詳細步驟和Python實現。

## **問題分析**

給定三個整數 `n`、`b` 和 `c`，我們首先生成一個長度為 `n` 的陣列 `a`，其中每個元素 `a[i] = b * (i - 1) + c`。目標是通過一系列操作將這個陣列轉換為包含 `0` 到 `n-1` 的排列。每次操作中，Alice會將陣列中的最大元素（如果有多個，則選擇最左邊的一個）替換為陣列的 `MEX`（最小缺失整數）。

### **關鍵觀察**

1. **當 `b ≠ 0` 時：**
   - 初始陣列 `a` 中的元素為 `c, c+b, c+2b, ..., c+(n-1)b`，這些元素是遞增且互不相同的。
   - 我們需要確定有多少個元素在 `[0, n-1]` 範圍內，設為 `k`。
   - 所需的操作數為 `n - k`，因為需要替換 `n - k` 個不在範圍內的元素來填補缺失的數字。

2. **當 `b = 0` 時：**
   - 如果 `c = 0`：
     - 當 `n ≤ 2` 時，可以通過 `n - 1` 次操作得到排列。
     - 當 `n > 2` 時，無法通過有限次操作得到排列。
   - 如果 `c ≠ 0`：
     - 如果 `c < n`，初始陣列中有一個元素在 `[0, n-1]` 範圍內，所需的操作數為 `n - 1`。
     - 如果 `c ≥ n`，初始陣列中沒有元素在 `[0, n-1]` 範圍內，所需的操作數為 `n`。

### **實現步驟**

1. **處理 `b ≠ 0` 的情況：**
   - 計算有多少個元素在 `[0, n-1]` 範圍內。
   - `k = min(n, floor((n-1 - c)/b) + 1)`，前提是 `c ≤ n - 1`，否則 `k = 0`。
   - 最終答案為 `n - k`。

2. **處理 `b = 0` 的情況：**
   - 如果 `c = 0`：
     - 如果 `n ≤ 2`，答案為 `n - 1`。
     - 否則，答案為 `-1`（不可能）。
   - 如果 `c ≠ 0`：
     - 如果 `c < n`，`k = 1`，答案為 `n - 1`。
     - 否則，`k = 0`，答案為 `n`。

### **Python 實現**

```python
import sys
import math

def solve():
    import sys
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    idx =1
    results=[]
    for _ in range(t):
        n_str,b_str,c_str = data[idx], data[idx+1], data[idx+2]
        idx +=3
        n = int(n_str)
        b = int(b_str)
        c = int(c_str)
        if b !=0:
            if c > n -1:
                k=0
            else:
                # Compute floor((n-1 -c)/b) +1
                # Since c <=n -1 and b >0, (n-1 -c) >=0
                tmp = (n -1 -c) // b +1
                k = min(tmp, n)
            answer = n -k
        else:
            if c ==0:
                if n <=2:
                    answer = n -1
                else:
                    answer = -1
            else:
                if c <n:
                    k=1
                else:
                    k=0
                answer =n -k
        results.append(str(answer))
    print('\n'.join(results))
```

## **程式碼說明**

1. **輸入處理：**
   - 讀取所有輸入並分割為列表 `data`。
   - 第一個元素是測試案例數 `t`。
   - 接下來每三個數字代表一個測試案例的 `n`、`b` 和 `c`。

2. **處理每個測試案例：**
   - 如果 `b ≠ 0`：
     - 檢查 `c` 是否大於 `n-1`。
     - 如果 `c ≤ n-1`，計算有多少個元素在 `[0, n-1]` 範圍內，並確保不超過 `n`。
     - 計算所需的操作數為 `n - k`。
   - 如果 `b = 0`：
     - 根據 `c` 的值和 `n` 的大小決定是否可能以及需要多少次操作。
   - 將結果儲存到 `results` 列表中。

3. **輸出結果：**
   - 將所有測試案例的答案逐行輸出。

## **結論**

這個問題的核心在於計算初始陣列中有多少元素已經在目標排列 `[0, n-1]` 中，並且根據不同的 `b` 和 `c` 的值來判斷最少需要多少次操作來達成目標。如果無法達成，則輸出 `-1`。