# CF449D Jzzhu and Numbers

> Power by Gemini 2.5 Pro

### 解題者的思考歷程：CF449D Jzzhu and Numbers

當我第一次看到這個題目時，我的目標是找出有多少個非空子集合，其所有元素的位元 AND (bitwise AND) 運算結果為 0。

#### 步驟一：初步分析與暴力解法

題目要求從 $n$ 個數中選出一個子集（大小為 $k \ge 1$），使得子集內所有數字的 AND 值為 0。

最直觀的想法是：窮舉所有可能的子集。一個大小為 $n$ 的集合，總共有 $2^n - 1$ 個非空子集。對於每一個子集，我都計算其中所有元素的 AND 值，然後檢查結果是否為 0。

*   **複雜度分析**：$n$ 最大可達 $10^6$。$2^{10^6}$ 是一個天文數字，這個方法顯然是行不通的。我必須找到一個更高效的演算法。

#### 步驟二：轉換思考角度

「AND 結果**恰好**為 0」這個條件很難直接計算。在組合計數問題中，當「恰好」很難時，我們通常會轉向思考「至少」或「至多」的問題，然後利用**容斥原理 (Inclusion-Exclusion Principle)** 來求得最終答案。

讓我們換個角度思考。與其直接求 AND 為 0 的數量，不如考慮 AND 結果為其他值的狀況。

*   令 $ans(S)$ 為 AND 結果**恰好**為 $S$ 的子集數量。我們要求的目標是 $ans(0)$。
*   直接計算 $ans(S)$ 仍然很困難。讓我們定義一個更容易計算的輔助函數。
*   令 $N(S)$ 為 AND 結果是 $S$ 的**超集 (superset)** 的子集數量。也就是說，對於一個子集，其 AND 結果為 $R$，如果 $R \ \& \ S = S$，那麼這個子集就被計入 $N(S)$。

為什麼 $N(S)$ 比較容易計算？
一個子集的 AND 結果 $R$ 是 $S$ 的超集，這等價於**子集中的每一個元素**都是 $S$ 的超集。
證明：如果子集中的所有數 $a_{i_j}$ 都滿足 $a_{i_j} \ \& \ S = S$，那麼它們的 AND 結果 $(...a_{i_j}...) \ \& \ S$ 也必然等於 $S$。

所以，計算 $N(S)$ 的步驟如下：
1.  找出在輸入陣列 $A$ 中，有多少個數是 $S$ 的超集。我們稱這個數量為 $C(S)$。
2.  從這 $C(S)$ 個數中，任選一個非空子集，它們的 AND 結果都將是 $S$ 的超集。
3.  因此，$N(S)$ 就是從 $C(S)$ 個元素中選出非空子集的數量，即 $2^{C(S)} - 1$。

現在我們有了 $N(S)$ 和 $ans(S)$ 的關係：
$N(S) = \sum_{T \supseteq S} ans(T)$
(一個 AND 結果為 $S$ 的超集 $T$ 的子集，當然也滿足 AND 結果是 $S$ 的超集)

#### 步驟三：應用容斥原理

我們有了 $N(S)$，但需要求 $ans(0)$。根據子集反演（或直接使用容斥原理），我們可以得到 $ans(S)$ 的表達式：
$ans(S) = \sum_{T \supseteq S} (-1)^{|T| - |S|} N(T)$
其中 $|X|$ 代表數字 $X$ 在二進位表示下 1 的個數 (popcount)。

我們要求的是 $ans(0)$，代入 $S=0$：
$ans(0) = \sum_{T \supseteq 0} (-1)^{|T| - |0|} N(T)$
由於任何數都是 0 的超集，且 $|0|=0$，公式簡化為：
$ans(0) = \sum_{T=0}^{U-1} (-1)^{|T|} N(T)$
其中 $U$ 是可能出現的最大值的上界（大約 $10^6$，實際上是 $2^{20}$）。

將 $N(T) = 2^{C(T)} - 1$ 代入：
$ans(0) = \sum_{T=0}^{U-1} (-1)^{|T|} (2^{C(T)} - 1)$

這個公式看起來就是最終答案了！現在的挑戰變成：如何快速計算所有 $T$ 的 $C(T)$ 值？

#### 步驟四：高效計算 $C(T)$ - SOS DP (Sum Over Subsets DP)

$C(T)$ 的定義是輸入中 $T$ 的超集的數量。
$C(T) = \sum_{a_i \supseteq T} 1$

如果我們對每個 $T$ 都遍歷一次所有輸入數字 $a_i$，總複雜度會是 $O(U \cdot n)$，依然太慢。

這裡就需要一種稱為 **SOS DP (Sum Over Subsets DP)** 的技巧。雖然名字是「子集和」，但它可以輕鬆修改為「超集和」。我們的目標是計算 `C[mask]`，即 `sum(initial_counts[i])` for all `i` that are supersets of `mask`。

這個 DP 的思路是按位元進行。
1.  **初始化**：建立一個陣列 `f`，大小為 $U$。`f[i]` 儲存輸入數字中等於 `i` 的個數。這一步的複雜度是 $O(n)$。
2.  **DP 轉移**：我們遍歷每一個位元 `i` (从 0 到 B-1，B 約為 20)。對於每個位元，我们再遍歷所有可能的數字 `s`。如果 `s` 的第 `i` 位是 1，那麼 `s` 同時也是 `s` 去掉第 `i` 位後數字 `s ^ (1 << i)` 的超集。因此，我們需要將 `f[s]` 的計數貢獻給 `f[s ^ (1 << i)]`。
    轉移方程為：`f[s ^ (1 << i)] += f[s]`

為了確保不重複計算，內層循環需要從大到小遍歷 `s`。這樣可以保證在處理位元 `i` 時，我們用來更新 `f[s ^ (1 << i)]` 的 `f[s]` 值，是本輪開始前的值，而不是已經被同一輪中其他數字更新過的值。

```python
# B 是最大位元數, U = 1 << B
for i in range(B):
    for s in range(U - 1, -1, -1):
        if (s >> i) & 1:  # 如果 s 的第 i 位是 1
            f[s ^ (1 << i)] += f[s]
```

經過這個 DP 過程後，`f[s]` 的值就變成了我們想要的 $C(s)$，即輸入中 `s` 的超集的數量。整個 DP 的複雜度是 $O(B \cdot U)$，這是可接受的。

#### 步驟五：整合程式碼邏輯

現在我們把所有部分串聯起來，對照 AC Code 來理解：

1.  **初始化**
    ```python
    MOD = int(1e9 + 7)
    n = int(input())
    A = list(map(int, input().split()))
    B = max(A).bit_length() # 計算所需的最大位元數
    U = 1 << B             # 狀態空間大小
  
    f = [0] * U
    for x in A:
        f[x] += 1
    ```
    這部分對應 SOS DP 的初始化。

2.  **SOS DP 計算 C(s)**
    ```python
    for i in range(B):
        for s in range(U - 1, -1, -1):
            if (s >> i) & 1:
                f[s ^ (1 << i)] += f[s]
    ```
    這部分執行超集和 DP。執行完畢後，`f[s]` 就等於 $C(s)$。

3.  **計算最終答案**
    我們需要計算 $\sum_{i=0}^{U-1} (-1)^{|i|} (2^{f[i]} - 1)$。
    程式碼採用了一個巧妙的分組方式來實現。它沒有直接遍歷 `i` 來計算，而是先把 popcount 相同的項歸類。

    ```python
    g = [0] * (B + 1)
    for i in range(U):
        # f[i] 就是 C(i)
        # term = pow(2, f[i], MOD) - 1 就是 N(i)
        term = pow(2, f[i], MOD) - 1
      
        # 將 N(i) 加到對應 popcount 的組裡
        g[i.bit_count()] += term
        g[i.bit_count()] %= MOD
    ```
    這段程式碼執行後，`g[k]` 就等於 $\sum_{i \text{ s.t. } |i|=k} N(i)$。

    最後，根據容斥原理的公式，我們需要對這些 `g[k]` 進行交錯求和：
    $ans(0) = g[0] - g[1] + g[2] - g[3] + \dots$
    $ans(0) = \sum_{k=0}^{B} (-1)^k g[k]$

    ```python
    ans = 0
    for i in range(B + 1):
        if i & 1: # i 是奇數
            ans -= g[i]
        else:     # i 是偶數
            ans += g[i]
        ans %= MOD
    print(ans)
    ```
    這段程式碼完美地實現了最終的交錯求和，從而得到 $ans(0)$。

### 總結

整個解題思路是一個從暴力解法出發，意識到其不可行性後，轉向使用組合計數中的經典工具——容斥原理。為了應用容斥原理，我們定義了更容易計算的輔助函數 $N(S)$，並找到了它與目標 $ans(S)$ 之間的關係。計算 $N(S)$ 的瓶頸在於如何快速求出 $C(S)$，這引導我們使用了 SOS DP 這種高效的位元 DP 技巧。最後，將所有部分組合起來，就得到了一個既正確又高效的解決方案。這是一個典型的、將數論（容斥原理）與動態規劃（SOS DP）巧妙結合的範例。