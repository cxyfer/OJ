### 詳細解釋程式碼

本題目要求在兩個長度為 $n$ 的排列 $p$ 和 $q$ 中，計算有多少對 $(l, r)$ 滿足以下條件：
$$
\text{MEX}(p_l, p_{l+1}, \ldots, p_r) = \text{MEX}(q_l, q_{l+1}, \ldots, q_r)
$$
其中，$\text{MEX}$ 表示序列中缺失的最小正整數。

以下將對提供的 Python 程式碼進行詳細解釋，說明其運作原理與核心邏輯。

#### 1. 初始輸入與處理

```python
n = int(input())

P = list(map(lambda x: int(x) - 1, input().split()))
Q = list(map(lambda x: int(x) - 1, input().split()))
```

- **讀取輸入**
  - 首先讀取整數 $n$，表示排列的長度。
  - 接著讀取兩個排列 $p$ 和 $q$，並將每個元素減 $1$ 以便於後續以 $0$ 為起始索引進行處理。

#### 2. 建立位置映射

```python
A, B = [0] * n, [0] * n
for i, (x, y) in enumerate(zip(P, Q)):
    A[x] = i
    B[y] = i
```

- **建立索引映射**
  - 創建兩個列表 $A$ 和 $B$，用來記錄每個數字在排列 $p$ 和 $q$ 中的位置。
  - 透過遍歷排列 $p$ 和 $q$，將數字 $x$ 在 $p$ 中的位置記錄於 $A[x]$，數字 $y$ 在 $q$ 中的位置記錄於 $B[y]$。
  - 這樣做的目的是方便後續快速查找特定數字在兩個排列中的位置。

#### 3. 核心邏輯：遍歷所有可能的 MEX 值

```python
ans = 0
maxl, minr = n, -1
# 枚舉 MEX 值
for mex in range(1, n + 1):
    maxl = min(maxl, A[mex - 1], B[mex - 1])
    minr = max(minr, A[mex - 1], B[mex - 1])
    
    minl = 0
    maxr = n - 1
    
    if mex < n:
        if A[mex] < maxl:
            minl = max(minl, A[mex] + 1)
        else:
            maxr = min(maxr, A[mex] - 1)
            
        if B[mex] < maxl:
            minl = max(minl, B[mex] + 1)
        else:
            maxr = min(maxr, B[mex] - 1)
    
    if maxl >= minl and maxr >= minr:
        ans += (maxl - minl + 1) * (maxr - minr + 1)
```

- **遍歷 MEX 的所有可能值**
  - 由 $1$ 到 $n$，逐一考慮每個可能的 $\text{MEX}$ 值。

- **確定 $maxl$ 與 $minr$**
  - 對於當前的 $\text{mex}$ 值，需確保在區間 $[l, r]$ 中，數字 $1$ 到 $\text{mex}-1$ 都出現，且 $\text{mex}$ 未出現。
  - 因此，找到數字 $\text{mex}-1$ 在 $p$ 和 $q$ 中出現的最早位置，並更新 $maxl$ 為這些位置的最小值，確保 $l$ 不低於此位置。
  - 同時，找到數字 $\text{mex}-1$ 在 $p$ 和 $q$ 中出現的最晚位置，更新 $minr$ 為這些位置的最大值，確保 $r$ 不小於此位置。

- **初始化 $minl$ 和 $maxr$**
  - 初始時，$minl = 0$，$maxr = n-1$，表示 $l$ 可以從 $0$ 開始，$r$ 可以到 $n-1$ 結束。

- **處理 $\text{mex}$ 值本身的出現**
  - 若 $\text{mex} < n$，則需確保在區間 $[l, r]$ 中，$\text{mex}$ 沒有出現。
  - 將 $\text{mex}$ 在 $p$ 和 $q$ 中的位置進行判斷：
    - 如果 $\text{mex}$ 在 $p$ 中的位置小於 $maxl$，則 $l$ 必須大於該位置，即 $l \geq A[\text{mex}] + 1$。
    - 否則，$r$ 必須小於該位置，即 $r \leq A[\text{mex}] - 1$。
    - 同理，對排列 $q$ 進行同樣的判斷，更新 $minl$ 和 $maxr$。

- **計算合法區間數量**
  - 若更新後滿足 $maxl \geq minl$ 且 $maxr \geq minr$，則該 $\text{mex}$ 下的合法區間數量為 $(maxl - minl + 1) \times (maxr - minr + 1)$。
  - 將此值累加到答案 $ans$ 中。

#### 4. 特殊情況處理：$\text{mex} = 1$

```python
l = min(A[0], B[0])
r = min(n - 1 - A[0], n - 1 - B[0])
m = abs(A[0] - B[0]) - 1

ans += l * (l + 1) // 2
ans += r * (r + 1) // 2
ans += m * (m + 1) // 2
```

- **$\text{mex} = 1$ 的特別處理**
  - 當 $\text{mex} = 1$ 時，代表在區間 $[l, r]$ 中，數字 $1$ 沒有出現。
  - 因此，滿足條件的區間必須不包含數字 $1$。
  
- **計算不包含 $1$ 的區間數量**
  - 找出數字 $1$ 在排列 $p$ 和 $q$ 中的位置：
    - $A[0]$ 是數字 $1$ 在 $p$ 中的位置。
    - $B[0]$ 是數字 $1$ 在 $q$ 中的位置。
  
  - **找出可行的左邊界與右邊界：**
    - 左邊界最大不能超過 $A[0]$ 和 $B[0]$ 之一的最小值。
    - 右邊界最大不能超過 $n - 1 - A[0]$ 和 $n - 1 - B[0]$ 的最小值。
    - 中間可能的間隔長度為 $|A[0] - B[0]| - 1$。
  
  - **累加不包含 $1$ 的區間數量：**
    - 使用等差數列的公式計算區間數量：
      - 第一部分 $l * (l + 1) // 2$ 計算左側的可行區間數量。
      - 第二部分 $r * (r + 1) // 2$ 計算右側的可行區間數量。
      - 第三部分 $m * (m + 1) // 2$ 計算中間的可行區間數量。
    - 將這三部分的數量加總後，累加到總答案 $ans$ 中。

#### 5. 輸出結果

```python
print(ans)
```

- **輸出最終答案**
  - 將計算出來的符合條件的區間對數量 $ans$ 輸出。

#### 6. 總結

整體而言，該程式碼的核心思想是：

1. **遍歷所有可能的 $\text{MEX}$ 值**（從 $1$ 到 $n$），對每個 $\text{MEX}$，計算滿足條件的區間對數量。
2. **利用位置映射**，快速定位特定數字在兩個排列中的出現位置，以確定區間的左右邊界。
3. **特別處理 $\text{MEX} = 1$ 的情況**，因為這是唯一不依賴其他數字出現的特殊情形。
4. **累加所有合法區間的數量**，最終得到符合條件的 $(l, r)$ 對數量。

這種方法有效地將問題轉化為對每個 $\text{MEX}$ 值的區間數量進行計算，並通過位置映射與邊界限制來確保每個區間的合法性，使得整體時間複雜度保持在 $O(n)$ 水平，適用於題目中的大數據限制。